# HarmoNet マルチテナント設計仕様書 v1.1（Part1）
文書バージョン: 1.1
作成日: 2025年10月30日
最終更新日: 2025年10月30日
文書管理番号: HARMONET-MULTI-TENANT-001

---

## 第1章 ドキュメント概要

### 1.1 目的
本書は、HarmoNet プロジェクトにおけるマルチテナント型アーキテクチャの設計仕様を定義する。  
複数の管理組合・住宅群・施設を単一プラットフォーム上で安全かつ効率的に管理するための技術的設計方針を示す。

### 1.2 適用範囲
本書は、HarmoNet アプリケーションの **バックエンド構成・データ分離・テナント初期化・RLS制御** に関わる全ての実装方針を対象とする。  
対象範囲には以下を含む：
- NestJS / Prisma / PostgreSQL を中心としたバックエンド構成
- Supabase Row Level Security (RLS) 設計
- テナントデータモデルと設定マスタ構造
- テナントライフサイクル管理（作成・削除・保守）

### 1.3 背景
HarmoNet は、地域コミュニティ運営を支援する SaaS 型住民コミュニケーションプラットフォームであり、  
1つのアプリケーションから複数の住宅群・管理組合を管理する「マルチテナント型 SaaS アーキテクチャ」を採用する。

### 1.4 開発体制
AI協調開発方式を採用し、以下のAIエージェントが分担して開発を行う。

| AI | 主担当領域 |
|----|-------------|
| Claude | 画面設計・UXデザイン・構造化ドキュメント |
| Gemini | 開発環境構築・インフラ設定・CI/CD |
| GPT（タチコマ） | コード生成・ドキュメント統合・設計レビュー |

---

## 第2章 システム構成概要

### 2.1 システム構成概要図

```
[User] ─→ [React PWA] ─→ [NestJS + Prisma API] ─→ [Supabase PostgreSQL (RLS)]
                                   │
                                   ├─ [Supabase Auth / Storage]
                                   ├─ [SendGrid / SES (Mail)]
                                   └─ [Firebase Cloud Messaging]
```

### 2.2 採用技術スタック

| レイヤー | 技術 | 備考 |
|-----------|------|------|
| バックエンド | NestJS (Node.js 10.x) | APIサーバー |
| ORM | Prisma ORM 5.x | スキーマ自動生成・マルチテナント対応 |
| データベース | PostgreSQL (Supabase) | Row Level Security適用 |
| キャッシュ | Redis 7.x | セッション・翻訳キャッシュ |
| フロント | React + PWA | スマートフォン・PC対応 |
| ホスティング | Vercel + Supabase | MVP構成 |
| 通知 | Firebase Cloud Messaging | iOS/Android通知 |
| メール配信 | SendGrid / Amazon SES | 認証・予約・通知用途 |
| 翻訳 | Google Cloud Translation API | 日・英・中翻訳 |
| 認証 | Magic Link (NextAuth) | パスワードレス方式 |

### 2.3 マルチテナント方式
- **論理分離方式**：単一データベース内で tenant_id により分離。
- **Row Level Security (RLS)** により DB側でもアクセス制御。
- **アプリ層制御**：Prismaミドルウェアにより全クエリに tenant_id を自動付与。
- **スキーマ分離方式（物理分離）** は将来のスケーリングフェーズで検討。

### 2.4 テナント識別方式
- `tenant_id`: UUID v4 形式で一意に採番。
- テナント識別はログイン時の JWT ペイロードに含まれる。
- APIアクセス時、ミドルウェアでtenant_idを解決し、クエリスコープに注入。

---

## 第3章 テナントモデル設計

### 3.1 テーブル構造概要

| テーブル名 | 主目的 |
|-------------|----------|
| tenant | テナント基本情報 |
| tenant_user | テナント所属ユーザー情報 |
| tenant_features | 有効機能設定 |
| tenant_settings | テナント固有設定 (JSON) |

### 3.2 tenant テーブル

| カラム名 | 型 | 説明 |
|-----------|----|------|
| id | UUID | テナント識別子 |
| name | VARCHAR(100) | テナント名称（例：A棟管理組合） |
| code | VARCHAR(50) | 識別コード（URLサブドメイン用） |
| status | VARCHAR(20) | active / suspended / deleted |
| created_at | TIMESTAMP | 作成日時 |
| updated_at | TIMESTAMP | 更新日時 |

### 3.3 tenant_user テーブル

| カラム名 | 型 | 説明 |
|-----------|----|------|
| id | UUID | 識別子 |
| tenant_id | UUID | 紐付くテナント |
| user_id | UUID | Supabase AuthユーザーID |
| role | VARCHAR(20) | admin / member |
| joined_at | TIMESTAMP | 参加日時 |
| last_login_at | TIMESTAMP | 最終ログイン日時 |

### 3.4 tenant_features テーブル

| カラム名 | 型 | 説明 |
|-----------|----|------|
| id | SERIAL | 主キー |
| tenant_id | UUID | 紐付くテナント |
| feature_name | VARCHAR(50) | 機能名 |
| enabled | BOOLEAN | 有効化フラグ |
| updated_at | TIMESTAMP | 更新日時 |

**feature_name の定義例**:
```
announcement
bbs
parking
survey
consumables
watch_camera
care_support
```
※ 新規追加 `"consumables"` は「住宅設備・消耗品照会／発注機能」を表す。

### 3.5 tenant_settings テーブル

| カラム名 | 型 | 説明 |
|-----------|----|------|
| id | SERIAL | 主キー |
| tenant_id | UUID | 紐付くテナント |
| settings_json | JSONB | 設定データ（テーマ・予約制限等） |
| updated_at | TIMESTAMP | 更新日時 |

**settings_json 構造例**
```json
{
  "theme": "light",
  "language_default": "ja",
  "parking": {
    "max_days": 3,
    "allow_consecutive": false
  },
  "features_enabled": ["bbs", "parking", "announcement", "survey", "consumables"]
}
```

---

## 第4章 テナントライフサイクル管理

### 4.1 テナント作成フロー
1. 管理者が新規テナント作成APIを呼び出す。  
2. tenantレコードを生成。  
3. 初期機能を tenant_features に登録。  
4. 初期設定JSONを tenant_settings に生成。  
5. Supabase Auth に管理者ユーザーを登録。  

**初期有効機能例:**
```
["bbs", "announcement", "parking", "survey"]
```

将来的には `consumables` を管理者ダッシュボードから有効化可能とする。

### 4.2 テナント削除フロー
- `status` を `deleted` に更新（論理削除）。
- 関連テーブル（tenant_user, tenant_features 等）は保持。
- Supabase RLSポリシーにより削除済みテナントは参照不可。

### 4.3 Row Level Security (RLS) 設計

**目的:**  
RLSにより、ユーザーが所属するテナント以外のデータを閲覧・操作できないよう制御する。

**ポリシー例:**
```sql
CREATE POLICY tenant_isolation_policy
ON public.bbs_posts
USING (tenant_id = auth.jwt() ->> 'tenant_id');
```

- Supabase AuthのJWTペイロードに `tenant_id` を含める。  
- Prismaからのリクエストでは、ミドルウェアで tenant_id を付与して発行。  

### 4.4 Prisma ミドルウェアによる制御
```ts
prisma.$use(async (params, next) => {
  if (params.args?.data && context.tenantId) {
    params.args.data.tenant_id = context.tenantId;
  }
  return next(params);
});
```

### 4.5 テナント監査ログ
- tenantごとに操作ログをJSON形式で記録。
- Supabase Storageに1ヶ月保管。

---
【次章：第5章 API設計（Part2に続く）】
